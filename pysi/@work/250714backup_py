250714backup.py



#@250712 ADD
def load_sku_cost_master(file_path: str, node_dict: dict[str, Node]):
    df = pd.read_csv(file_path)

    for _, row in df.iterrows():
        node_name = row["node_name"]
        product_name = row["product_name"]

        if node_name not in node_dict:
            print(f"[Warn] Node {node_name} not found in node_dict")
            continue

        node = node_dict[node_name]

        sku = node.sku_dict.get(product_name)

        if sku is None:
            sku = node.add_sku(product_name)

        # ‰∏ÄÊã¨„Ç≥„Çπ„Éà„Çª„ÉÉ„Éà
        sku.set_cost_attr(
            price_sales_shipped=float(row["price_sales_shipped"]),
            cost_total=float(row["cost_total"]),
            profit=float(row["profit"]),
            marketing_promotion=float(row.get("marketing_promotion", 0)),
            sales_admin_cost=float(row.get("sales_admin_cost", 0)),
            logistics_costs=float(row.get("logistics_costs", 0)),
            warehouse_cost=float(row.get("warehouse_cost", 0)),
            direct_materials_costs=float(row["direct_materials_costs"]),
            prod_indirect_labor=float(row.get("prod_indirect_labor", 0)),
            prod_indirect_others=float(row.get("prod_indirect_others", 0)),
            direct_labor_costs=float(row.get("direct_labor_costs", 0)),
            depreciation_others=float(row.get("depreciation_others", 0)),
        )





# *************************
# class SKU
# *************************

class SKU:
    def __init__(self, product_name, node_name):
        self.product_name = product_name

        self.node_name = node_name 
        # node_dict[sku.node_name] „ÅßNode„Å∏„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã


        self.psi_table = defaultdict(lambda: {"I": 0, "P": 0, "S": 0, "CO": 0})  # weekÂçò‰Ωç



#
#
# ÈÄî‰∏≠ÁúÅÁï•
#
#


## ‚úÖ ‚ë† `SKU.set_cost_attr()` „ÅÆËøΩÂä†ÂÆöÁæ©Ê°àÔºàNodeÁâà„Å´Ê∫ñÊã†Ôºâ
### üîß `SKU`„ÇØ„É©„ÇπÂÜÖ„Å´‰ª•‰∏ã„ÇíËøΩÂä†Ôºö

    def set_cost_attr(
        self,
        price_sales_shipped,
        cost_total,
        profit,
        marketing_promotion=None,
        sales_admin_cost=None,
        SGA_total=None,
        logistics_costs=None,
        warehouse_cost=None,
        direct_materials_costs=None,
        purchase_total_cost=None,
        prod_indirect_labor=None,
        prod_indirect_others=None,
        direct_labor_costs=None,
        depreciation_others=None,
        manufacturing_overhead=None,
        ):

        self.price_sales_shipped = price_sales_shipped
        self.cost_total = cost_total
        self.profit = profit
        self.marketing_promotion = marketing_promotion or 0
        self.sales_admin_cost = sales_admin_cost or 0

        self.SGA_total = SGA_total or (self.marketing_promotion + self.sales_admin_cost)
    
        self.logistics_costs = logistics_costs or 0
        self.warehouse_cost = warehouse_cost or 0
        self.direct_materials_costs = direct_materials_costs or 0

        self.purchase_total_cost = purchase_total_cost or (
        self.logistics_costs + self.warehouse_cost + self.direct_materials_costs )

        self.prod_indirect_labor = prod_indirect_labor or 0
        self.prod_indirect_others = prod_indirect_others or 0
        self.direct_labor_costs = direct_labor_costs or 0
        self.depreciation_others = depreciation_others or 0
        self.manufacturing_overhead = manufacturing_overhead or (
        self.prod_indirect_labor + self.prod_indirect_others + self.direct_labor_costs + self.depreciation_others
        )
    
    




#@250712 ADD
def load_sku_cost_master(file_path: str, node_dict: dict[str, Node]):
    df = pd.read_csv(file_path)

    for _, row in df.iterrows():
        node_name = row["node_name"]
        product_name = row["product_name"]

        if node_name not in node_dict:
            print(f"[Warn] Node {node_name} not found in node_dict")
            continue

        node = node_dict[node_name]

        sku = node.sku_dict.get(product_name)
        if sku is None:
            sku = node.add_sku(product_name)

        # ‰∏ÄÊã¨„Ç≥„Çπ„Éà„Çª„ÉÉ„Éà
        sku.set_cost_attr(
            price_sales_shipped=float(row["price_sales_shipped"]),
            cost_total=float(row["cost_total"]),
            profit=float(row["profit"]),
            marketing_promotion=float(row.get("marketing_promotion", 0)),
            sales_admin_cost=float(row.get("sales_admin_cost", 0)),
            logistics_costs=float(row.get("logistics_costs", 0)),
            warehouse_cost=float(row.get("warehouse_cost", 0)),
            direct_materials_costs=float(row["direct_materials_costs"]),
            prod_indirect_labor=float(row.get("prod_indirect_labor", 0)),
            prod_indirect_others=float(row.get("prod_indirect_others", 0)),
            direct_labor_costs=float(row.get("direct_labor_costs", 0)),
            depreciation_others=float(row.get("depreciation_others", 0)),
        )


# **************************************************
# start from load_data_files(...)
# **************************************************


#@250630 STOP GO
    def load_data_files(self):
        directory = filedialog.askdirectory(title="Select Data Directory")

        if directory:
            try:
                self.lot_size = int(self.lot_size_entry.get())
                self.plan_year_st = int(self.plan_year_entry.get())
                self.plan_range = int(self.plan_range_entry.get())
            except ValueError:
                print("Invalid input for lot size, plan year start, or plan range. Using default values.")

            self.outbound_data = []
            self.inbound_data = []

            data_file_list = os.listdir(directory)

            print("data_file_list", data_file_list)

            self.directory = directory
            self.load_directory = directory

            # --- Load Tree Structures ---
            if "product_tree_outbound.csv" in data_file_list:
                file_path = os.path.join(directory, "product_tree_outbound.csv")
                nodes_outbound, root_node_name_out = create_tree_set_attribute(file_path)
                root_node_outbound = nodes_outbound[root_node_name_out]

                def make_leaf_nodes(node, leaf_list):
                    if not node.children:
                        leaf_list.append(node.name)
                    for child in node.children:
                        make_leaf_nodes(child, leaf_list)
                    return leaf_list

                leaf_nodes_out = make_leaf_nodes(root_node_outbound, [])
                self.nodes_outbound = nodes_outbound
                self.root_node_outbound = root_node_outbound
                self.leaf_nodes_out = leaf_nodes_out
                set_positions(root_node_outbound)
                set_parent_all(root_node_outbound)
                print_parent_all(root_node_outbound)

            else:
                print("error: product_tree_outbound.csv is missed")

            if "product_tree_inbound.csv" in data_file_list:
                file_path = os.path.join(directory, "product_tree_inbound.csv")
                nodes_inbound, root_node_name_in = create_tree_set_attribute(file_path)
                root_node_inbound = nodes_inbound[root_node_name_in]
                self.nodes_inbound = nodes_inbound
                self.root_node_inbound = root_node_inbound
                set_positions(root_node_inbound)
                set_parent_all(root_node_inbound)
                print_parent_all(root_node_inbound)
            else:
                print("error: product_tree_inbound.csv is missed")


            # **************************************
            # join nodes_outbound and nodes_inbound
            # **************************************


            # „Éû„Éº„Ç∏Ââç„Å´ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºà„É≠„Ç∞Âá∫Âäõ„ÅÇ„ÇäÔºâ
            overlapping_keys = set(nodes_inbound) & set(nodes_outbound)
            if overlapping_keys:
                print(f"[Warn] Overlapping node names: {overlapping_keys}")


            #@STOP python 3.9 upper
            #node_dict = nodes_inbound | nodes_outbound

            node_dict = {**nodes_inbound, **nodes_outbound}
            #  Ê≥®ÊÑèÔºöÈáçË§á„Ç≠„Éº„Åå„ÅÇ„Çã„Å®„ÄÅÂæå„Å´Âá∫„Å¶„Åè„ÇãËæûÊõ∏„ÅÆÂÄ§„Åß‰∏äÊõ∏„Åç„Åï„Çå„Åæ„Åô„ÄÇ
            # "supply_point"„Ååoutbound„Å®inbound„ÅßÈáçË§á„Åóoutbound„Åß‰∏äÊõ∏„Åç„Åï„Çå„Çã



            # ‰æã„Åà„Å∞ tree["root_node_inbound"] „Åã„Çâ productA „ÅÆÈÉ®ÂàÜ„ÉÑ„É™„Éº„ÇíÊäΩÂá∫„Åô„ÇãÂ†¥Âêà
            #@250713 STOP
            #subtree_inbound = extract_subtree_by_product(tree["root_node_inbound"], "productA")

            subtree_inbound = extract_subtree_by_product(root_node_inbound, "JPN_Koshihikari")

            #@250713 STOP
            #subtree_outbound = extract_subtree_by_product(tree["root_node_outbound"], "productA")
            
            subtree_outbound = extract_subtree_by_product(root_node_outbound, "JPN_Koshihikari")
            


            # Ê§úË®ºË°®Á§∫
            if subtree_inbound:
                print("Inbound subtree:")
                subtree_inbound.print_tree()
            
            if subtree_outbound:
                print("Outbound subtree:")
                subtree_outbound.print_tree()





            if "node_cost_table_outbound.csv" in data_file_list:

                load_sku_cost_master(os.path.join(directory, "sku_cost_table_outbound.csv"), self.nodes_outbound)

                #@STOP
                #read_set_cost(os.path.join(directory, "node_cost_table_outbound.csv"), self.nodes_outbound)

            else:
                print("error: node_cost_table_outbound.csv is missed")

            if "node_cost_table_inbound.csv" in data_file_list:

                load_sku_cost_master(os.path.join(directory, "sku_cost_table_inbound.csv"), self.nodes_outbound)

                #@STOP
                #read_set_cost(os.path.join(directory, "node_cost_table_inbound.csv"), self.nodes_inbound)

            else:
                print("error: node_cost_table_inbound.csv is missed")






